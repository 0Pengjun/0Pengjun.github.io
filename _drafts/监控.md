---
layout: post
title: '前端监控'
date: 2018-12-11
author: June
cover: /assets/img/post/2018-12-11/front-end-monitoring.png
tags: 前端
---

# 前端监控

<a data-fancybox="gallery" href="{{site.baseurl}}/assets/img/post/2018-12-11/structure.svg">
![文章结构]({{site.baseurl}}/assets/img/post/2018-12-11/structure.svg)
</a>

## 前端监控的目的

随着前后端分离，监控也可以分为前后端，前端监控与后端监控的关注不同。

<a data-fancybox="gallery" href="{{site.baseurl}}/assets/img/post/2018-12-11/focus.png">
![前端监控关注]({{site.baseurl}}/assets/img/post/2018-12-11/focus.png)
</a>

### 为什么要做前端监控

都知道监控的重要性，我觉得关键目的有三：

1. 获取用户体验相关的数据。
2. 当客户端出现故障时，能第一时间通知到前端负责人，定位故障，及时止损。
3. 获取用户行为以及跟踪产品在用户端的使用情况，并以监控数据为基础，指明产品优化的方向。

这三条分布对应监控内容的三个方面：性能监控、异常监控和数据监控。

### 监控什么

#### 性能监控

指标

* 白屏时间；
* 首屏时间（不同用户，不同机型和不同系统下的首屏加载时间）；
* 主要内容可见时间 FMP(first meaning paint)
* 页面渲染时间
* 用户可交互时间；
* 页面交互动画完成时间
* 总下载时间（静态资源整体下载时间）；
* TCP连接时间；
* HTTP响应时间；

#### 异常监控

指标

* Javascript的异常监控
* 样式丢失的异常监控
* 静态资源加载异常

#### 数据监控

指标

* PV/UV: PV (page view)，即页面浏览量或点击量。UV:指访问某个站点或点击某条新闻的不同IP地址的人数
* 用户在每一个页面的停留时间
* 用户通过什么入口来访问该网页
* 用户在相应的页面中触发的行为

## 如何进行前端监控

### 日志采集

收集异常日志，先在本地做一定的处理，采取一定的方案上报到服务器。

#### 采集内容

当异常出现的时候，我们需要知道异常的具体信息，根据异常的具体信息来决定采用什么样的解决方案。在采集异常信息时，可以遵循4W原则：

WHO did WHAT and get WHICH exception in WHICH environment?

1. 用户信息

出现异常时该用户的信息，例如该用户在当前时刻的状态、权限等，以及需要区分用户可多终端登录时，异常对应的是哪一个终端。

2. 行为信息

用户进行什么操作时产生了异常：所在的界面路径；执行了什么操作；操作时使用了哪些数据；当时的API吐了什么数据给客户端；如果是提交操作，提交了什么数据；上一个路径；上一个行为日志记录ID等。

3. 异常信息

产生异常的代码信息：用户操作的DOM元素节点；异常级别；异常类型；异常描述；代码stack信息等。

4. 环境信息

网络环境；设备型号和标识码；操作系统版本；客户端版本；API接口版本等。


#### 采集性能指标

白屏时间；HTTP响应时间；TCP连接时间；页面渲染时间；用户可交互时间(用户等待页面可用的时间)；页面交互动画完成时间；总下载时间（静态资源整体下载时间）；主要内容可见时间 FMP (first meaning paint)，可以直接使用window.performance接口获取

只是这里的首屏时间，不是真正的首屏时间，只是个接近值。
我觉得比较合理的实现是`加载最慢的图片的时间点 - performance.timing.navigationStart;` 这个要配合具体的业务写，就不上code了。

```js
handleAddListener('load', getTiming)

function handleAddListener(type, fn) {
    if (window.addEventListener) {
        window.addEventListener(type, fn)
    } else {
        window.attachEvent('on' + type, fn)
    }
}

function getTiming() {
    try {
        let time = performance.timing;
        let timingObj = {};

        let loadTime = (time.loadEventEnd - time.loadEventStart) / 1000;

        if (loadTime < 0) {
            setTimeout(function() {
                getTiming();
            }, 200);
            return;
        }

        timingObj['白屏时间'] = (time.domLoading - time.fetchStart) / 1000;

        timingObj['重定向时间'] = (time.redirectEnd - time.redirectStart) / 1000;

        timingObj['DNS解析时间'] = (time.domainLookupEnd - time.domainLookupStart) / 1000;

        timingObj['TCP完成握手时间'] = (time.connectEnd - time.connectStart) / 1000;

        timingObj['HTTP请求响应完成时间'] = (time.responseEnd - time.requestStart) / 1000;

        timingObj['DOM开始加载前所花费时间'] = (time.responseEnd - time.navigationStart) / 1000;

        timingObj['DOM加载完成时间'] = (time.domComplete - time.domLoading) / 1000;

        timingObj['DOM结构解析完成时间'] = (time.domInteractive - time.domLoading) / 1000;

        timingObj['脚本加载时间'] = (time.domContentLoadedEventEnd - time.domContentLoadedEventStart) / 1000;

        timingObj['伪首屏时间,页面加载完成的时间，用户等待页面可用的时间'] = (time.loadEventEnd - time.navigationStart) / 1000;

        timingObj['onload事件时间(页面交互动画完成时间)'] = (time.loadEventEnd - time.loadEventStart) / 1000;

        timingObj['总下载时间（静态资源整体下载时间）'] = (+new Date() - time.navigationStart) / 1000;

        timingObj['页面完全加载时间'] = (timingObj['重定向时间'] + timingObj['DNS解析时间'] + timingObj['TCP完成握手时间'] + timingObj['HTTP请求响应完成时间'] + timingObj['DOM结构解析完成时间'] + timingObj['DOM加载完成时间']);

        for (let item in timingObj) {
            console.log(item + ":" + timingObj[item] + '毫秒(ms)');
        }


    } catch (e) {
        console.log('error: ', e)
    }
}

let client = function() {

    //呈现引擎
    let engine = {
        ie: 0,
        gecko: 0,
        webkit: 0,
        khtml: 0,
        opera: 0,

        //完整的版本号
        ver: null
    };

    //浏览器
    let browser = {

        //主要的浏览器
        ie: 0,
        firefox: 0,
        safari: 0,
        konq: 0,
        opera: 0,
        chrome: 0,

        //具体版本号
        ver: null
    };

    //平台/设备/操作系统
    let system = {
        win: false,
        mac: false,
        x11: false,

        //移动设备
        iphone: false,
        ipod: false,
        ipad: false,
        ios: false,
        android: false,
        nokiaN: false,
        winMobile: false,

        //游戏系统
        wii: false,
        ps: false
    };

    //给上面的属性对象赋值(具体的检测方法实现)
    //检测呈现引擎和浏览器
    let ua = navigator.userAgent;
    if (window.opera) {
        engine.ver = browser.ver = window.opera.version();
        engine.opera = browser.opera = parseFloat(engine.ver);
    } else if (/AppleWebKit\/(\S+)/.test(ua)) {
        engine.ver = RegExp["$1"];
        engine.webkit = parseFloat(engine.ver);

        //确定是 Chrome or Safari
        if (/Chrome\/(\S+)/.test(ua)) {
            browser.ver = RegExp["$1"];
            browser.chrome = parseFloat(browser.ver);
        } else if (/Version\/(\S+)/.test(ua)) {
            browser.ver = RegExp["$1"];
            browser.safari = parseFloat(browser.ver);
        } else {
            //近似地确定版本号
            let safariVersion = 1;
            if (engine.webkit < 100) {
                safariVersion = 1;
            } else if (engine.webkit < 312) {
                safariVersion = 1.2;
            } else if (engine.webkit < 412) {
                safariVersion = 1.3;
            } else {
                safariVersion = 2;
            }

            browser.safari = browser.ver = safariVersion;
        }
    } else if (/KHTML\/(\S+)/.test(ua) || /Konqueror\/([^;]+)/.test(ua)) {
        engine.ver = browser.ver = RegExp["$1"];
        engine.khtml = browser.konq = parseFloat(engine.ver);
    } else if (/rv:([^\)]+)\) Gecko\/\d{8}/.test(ua)) {
        engine.ver = RegExp["$1"];
        engine.gecko = parseFloat(engine.ver);

        //确定是不是 Firefox
        if (/Firefox\/(\S+)/.test(ua)) {
            browser.ver = RegExp["$1"];
            browser.firefox = parseFloat(browser.ver);
        }
    } else if (/MSIE ([^;]+)/.test(ua)) {
        engine.ver = browser.ver = RegExp["$1"];
        engine.ie = browser.ie = parseFloat(engine.ver);
    }

    //检测浏览器
    browser.ie = engine.ie;
    browser.opera = engine.opera;


    //检测平台
    let p = navigator.platform;
    system.win = p.indexOf("Win") == 0;
    system.mac = p.indexOf("Mac") == 0;
    system.x11 = (p == "X11") || (p.indexOf("Linux") == 0);

    //检测 windows 操作系统
    if (system.win) {
        if (/Win(?:dows )?([^do]{2})\s?(\d+\.\d+)?/.test(ua)) {
            if (RegExp["$1"] == "NT") {
                switch (RegExp["$2"]) {
                    case "5.0":
                        system.win = "2000";
                        break;
                    case "5.1":
                        system.win = "XP";
                        break;
                    case "6.0":
                        system.win = "Vista";
                        break;
                    case "6.1":
                        system.win = "7";
                        break;
                    default:
                        system.win = "NT";
                        break;
                }
            } else if (RegExp["$1"] == "9x") {
                system.win = "ME";
            } else {
                system.win = RegExp["$1"];
            }
        }
    }

    //移动设备
    system.iphone = ua.indexOf("iPhone") > -1;
    system.ipod = ua.indexOf("iPod") > -1;
    system.ipad = ua.indexOf("iPad") > -1;
    system.nokiaN = ua.indexOf("NokiaN") > -1;

    //windows mobile
    if (system.win == "CE") {
        system.winMobile = system.win;
    } else if (system.win == "Ph") {
        if (/Windows Phone OS (\d+.\d+)/.test(ua)) {;
            system.win = "Phone";
            system.winMobile = parseFloat(RegExp["$1"]);
        }
    }


    //检测 iOS 版本
    if (system.mac && ua.indexOf("Mobile") > -1) {
        if (/CPU (?:iPhone )?OS (\d+_\d+)/.test(ua)) {
            system.ios = parseFloat(RegExp.$1.replace("_", "."));
        } else {
            system.ios = 2; //can't really detect - so guess
        }
    }

    //检测 Android 版本
    if (/Android (\d+\.\d+)/.test(ua)) {
        system.android = parseFloat(RegExp.$1);
    }

    //游戏系统
    system.wii = ua.indexOf("Wii") > -1;
    system.ps = /playstation/i.test(ua);

    //返回这些对象
    return {
        engine: engine,
        browser: browser,
        system: system
    };
}

function filterData(data) {

    for (const key in data) {
        // 去除对象内多余的数据
        if (data[key] === 0 || data[key] === false) delete data[key]
    }
}

// 过滤无效数据

let clientInfo = client()

filterData(clientInfo.browser)
filterData(clientInfo.engine)
filterData(clientInfo.system)

let envObj = {}

envObj['浏览器信息'] = Object.keys(clientInfo.browser)[0] + ' ' + clientInfo.browser.ver
envObj['浏览器引擎'] = Object.keys(clientInfo.engine)[0] + ' ' + clientInfo.engine.ver
envObj['系统'] = Object.keys(clientInfo.system)[0]

for (let item in envObj) {
    console.log(item + ": " + envObj[item])
}
```

#### 采集异常指标

* Javascript的异常监控
* 样式丢失的异常监控
判断是否已经加载 了相应的 样式文件
* 静态资源加载异常

使用框架的能力采集错误

AngularJS 的 `ErrorHandler` , Vue 的 `Vue.config.errorHandler`, React 16 的 `componentDidCatch` 。


前端错误日志（这个比较庞大，后面详述）

错误捕捉:前端错误捕捉，一般使用onerror，这个偶尔会被try cache影响

要想深入了解错误信息，这里便可以了解下source map

跨域资源监测（监测所有非白名单脚本，发现脚本注入行为，附件特性）

API成功率，也包括JS错误率
每次异步请求后端API的成功率以及响应延时

【访问明细】搜索用户ID-->搜索报错明细

#### 采集数据指标

* PV/UV: PV (page view)，即页面浏览量或点击量。UV:指访问某个站点或点击某条新闻的不同IP地址的人数
* 用户在每一个页面的停留时间（web不一定准确）
* 用户通过什么入口来访问该网页，即页面来源（web处理这个有些困难），定义页面从哪里来，在海量数据的情况下也可以不记录
* 用户在相应的页面中触发的行为

慢会话追踪




### 日志存储

后端接收前端上报的异常日志，经过一定处理，按照一定的存储方案存储。




### 统计与分析

分析分为机器自动分析和人工分析。

机器自动分析，通过预设的条件和算法，对存储的日志信息进行统计和筛选，发现问题，触发报警。

人工分析，通过提供一个可视化的数据面板，让系统用户可以看到具体的日志数据，根据信息，发现异常问题根源。

均值与分布

均值与分布是数据处理中最常见的两种方式。因为它能直观的表示指标的趋势与分布状况，方便进行评估、瓶颈发现与告警。处理过程中应去除异常值，例如明显超过阈值的脏数据等。

耗时的评估中，有很多这方面的研究数据。例如有人提出三个基本的时间范围：

* 0.1秒 : 0.1 秒是用户感知的最小粒度，在这个时间范围内完成的操作被认为是流畅没有延迟的
* 1.0秒 : 1.0 秒内完成的响应认为不会干扰用户的思维流。尽管用户能感觉到延迟，但 0.1 秒 -1.0 秒内完成的操作并不需要给出明显 loading 提示
* 10秒 : 达到 10 秒用户将无法保持注意力，很可能选择离开做其他事情

我们根据业界的一些调研，结合不同指标的特点，制定了指标的分布评估区间。如下图所示：

<a data-fancybox="gallery" href="{{site.baseurl}}/assets/img/post/2018-12-11/speed.png">
![页面速度]({{site.baseurl}}/assets/img/post/2018-12-11/speed.png)
</a>

评估区间的制定方便我们了解当前性能状况，同时对性能趋势波动做出反应。


### 报告和警告

分为告警和预警。

告警按照一定的级别自动报警，通过设定的渠道，按照一定的触发规则进行。

预警则在异常发生前，提前预判，给出警告。




日志服务进入数据处理流程之前进行采样率控制

异常监控上报

规则报警的问题，监控平台可以引入一些简单的数学模型来解决时序数据的异常识别工作。以最常见的高斯分布（正态分布）为例，利用 3-sigma 原则可以快速判断某一时刻的报错数是否满足概率分布，继而可以产生报警：

## 监控实战

sentry + vue

选用sentry，功能较完善，免费

数据可视化
可以查询任意时间段的数据
可以查看表现变化情况（趋势）
秒开率计算算法符合逻辑
展示首屏网络传输各个时刻的状态（转场、查询缓存、dns 解析、建立 tcp 连接等）
找出瓶颈页面
20%、80% 的页面处于哪个时间区间
找到处于某个时间区间的有哪些页面，以及各种网络信息
消息通知
线上性能表现差时，通过消息通知责任人优化，精确到页面

https://www.zhihu.com/question/19955915

工具推荐：

自动获取前端首屏时间：https://github.com/hoperyy/auto-compute-first-screen-time






http://mobile.51cto.com/hot-564045.htm

---

觉得文章不错就扫码支持一下呗～

![打赏二维码](https://june111.github.io/assets/img/post/pay-qr.jpg)

## 参考链接

* [2017前端监控系统探索总结](https://juejin.im/post/5a3e121451882533f01ec66d)
* [别再让你的web页面在用户浏览器端裸奔](http://www.aliued.com/?p=4162)
* [把前端监控做到极致](https://zhuanlan.zhihu.com/p/32262716)
* [前端监控和前端埋点方案设计](https://github.com/forthealllight/blog/issues/23)
* [GMTC 大前端时代前端监控的最佳实践](http://jm.taobao.org/2018/06/29/大前端时代前端监控的最佳实践)
* [前端异常监控解决方案研究](https://cdc.tencent.com/2018/09/13/frontend-exception-monitor-research/)
* [前端性能监控：window.performance](https://www.cnblogs.com/libin-1/p/6501951.html)
* [W3C Navigation Timing](https://www.w3.org/TR/navigation-timing/)
* [Web 性能优化-首屏和白屏时间](https://lz5z.com/Web性能优化-首屏和白屏时间/)
* [关于首屏时间采集自动化的解决方案](https://cloud.tencent.com/developer/article/1061844)
* [7 天打造前端性能监控系统 ](http://fex.baidu.com/blog/2014/05/build-performance-monitor-in-7-days/)
* [前端异常监控平台对比](https://www.jianshu.com/p/900e638648a7)
* []()
* []()
* []()
* []()
* [sentry vue](https://sentry.io/for/vue/)
* []()
* []()
* []()